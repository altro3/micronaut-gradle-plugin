/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package io.micronaut.gradle.testresources;

import io.micronaut.gradle.MicronautExtension;
import io.micronaut.testresources.buildtools.MavenDependency;
import io.micronaut.testresources.buildtools.TestResourcesClasspath;
import io.micronaut.testresources.buildtools.VersionInfo;
import org.gradle.api.GradleException;
import org.gradle.api.Plugin;
import org.gradle.api.Project;
import org.gradle.api.artifacts.Configuration;
import org.gradle.api.artifacts.Dependency;
import org.gradle.api.artifacts.ModuleDependency;
import org.gradle.api.artifacts.dsl.DependencyHandler;
import org.gradle.api.file.RegularFile;
import org.gradle.api.internal.project.ProjectInternal;
import org.gradle.api.provider.Provider;
import org.gradle.api.tasks.JavaExec;
import org.gradle.api.tasks.TaskContainer;
import org.gradle.api.tasks.TaskProvider;
import org.gradle.api.tasks.testing.Test;
import org.gradle.internal.event.ListenerManager;
import org.gradle.internal.service.ServiceRegistry;
import org.gradle.internal.session.BuildSessionLifecycleListener;

import java.lang.reflect.Field;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.Collections;
import java.util.List;
import java.util.UUID;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.stream.Collectors;
import java.util.stream.Stream;

/**
 * This plugin integrates with Micronaut Test Resources.
 * It handles the lifecycle of the test resources server
 * and provides configuration so that the user can precisely
 * tweak the behavior of the test resources server.
 */
public class MicronautTestResourcesPlugin implements Plugin<Project> {
    private final AtomicBoolean warned = new AtomicBoolean();

    public void apply(Project project) {
        project.getPluginManager().withPlugin("io.micronaut.component", unused -> configurePlugin(project));
    }

    private void configurePlugin(Project project) {
        Configuration server = createTestResourcesServerConfiguration(project);
        Provider<Integer> explicitPort = project.getProviders().systemProperty("micronaut.test-resources.server.port").map(Integer::parseInt);
        TestResourcesConfiguration config = createTestResourcesConfiguration(project, explicitPort);
        DependencyHandler dependencies = project.getDependencies();
        server.getDependencies().addAllLater(buildTestResourcesDependencyList(project, dependencies, config));
        Provider<RegularFile> portFile = project.getLayout().getBuildDirectory().file("test-resources-port.txt");
        String accessToken = UUID.randomUUID().toString();
        Provider<String> accessTokenProvider = project.getProviders().provider(() -> {
            if (explicitPort.isPresent()) {
                warnAboutPotentialSecurityIssue(project);
                return null;
            }
            return accessToken;
        });
        Provider<TestResourcesService> testResourcesService = registerTestResourcesService(project, server, explicitPort, portFile, accessTokenProvider);
        TaskContainer tasks = project.getTasks();
        TaskProvider<StartTestResourcesService> startTestResourcesService = createStartServiceTask(server, config, testResourcesService, tasks);
        TaskProvider<WriteServerSettings> writeTestProperties = createWriteTestPropertiesTask(project, explicitPort, config, portFile, accessTokenProvider, testResourcesService, tasks);
        project.getConfigurations().all(conf -> configureDependencies(project, config, dependencies, writeTestProperties, conf));

        tasks.withType(Test.class).configureEach(t -> t.dependsOn(startTestResourcesService));
        tasks.withType(JavaExec.class).configureEach(t -> t.dependsOn(startTestResourcesService));

        configureServiceReset((ProjectInternal) project);
    }

    private Provider<TestResourcesService> registerTestResourcesService(Project project, Configuration server, Provider<Integer> explicitPort, Provider<RegularFile> portFile, Provider<String> accessTokenProvider) {
        return project.getGradle().getSharedServices().registerIfAbsent("testResourcesService", TestResourcesService.class, spec -> {
            spec.getParameters().getClasspath().from(server);
            spec.getParameters().getPortFile().set(portFile);
            spec.getParameters().getPort().convention(explicitPort);
            spec.getParameters().getAccessToken().set(accessTokenProvider);
        });
    }

    private void configureDependencies(Project project, TestResourcesConfiguration config, DependencyHandler dependencies, TaskProvider<WriteServerSettings> writeTestProperties, Configuration conf) {
        String name = conf.getName();
        if ("developmentOnly".equals(name) || "testRuntimeOnly".equals(name)) {
            // Would be cleaner to use `config.getEnabled().zip(...)` but for some
            // reason it fails
            conf.getDependencies().addLater(config.getVersion().map(v -> {
                if (Boolean.TRUE.equals(config.getEnabled().get())) {
                    return dependencies.create("io.micronaut.testresources:micronaut-test-resources-client:" + v);
                }
                return null;
            }));
            conf.getDependencies().addLater(config.getEnabled().map(enabled -> {
                if (Boolean.TRUE.equals(enabled)) {
                    return dependencies.create(project.files(writeTestProperties));
                }
                return null;
            }));
        }
    }

    private TaskProvider<StartTestResourcesService> createStartServiceTask(Configuration server, TestResourcesConfiguration config, Provider<TestResourcesService> testResourcesService, TaskContainer tasks) {
        return tasks.register("startTestResourcesService", StartTestResourcesService.class, task -> {
            task.setOnlyIf(t -> config.getEnabled().get());
            task.getServer().set(testResourcesService);
            task.getClasspath().from(server);
        });
    }

    private TaskProvider<WriteServerSettings> createWriteTestPropertiesTask(Project project, Provider<Integer> explicitPort, TestResourcesConfiguration config, Provider<RegularFile> portFile, Provider<String> accessTokenProvider, Provider<TestResourcesService> testResourcesService, TaskContainer tasks) {
        return tasks.register("writeTestResourceProperties", WriteServerSettings.class, task -> {
            if (Boolean.TRUE.equals(config.getEnabled().get()) && !explicitPort.isPresent()) {
                // This is a very ugly hack, but we need the port of the server
                // to be available when the task gets configured
                Path portFilePath = portFile.get().getAsFile().toPath();
                testResourcesService.get(); // force startup of service
                while (!Files.exists(portFilePath)) {
                    try {
                        // Give some time for the server to start
                        Thread.sleep(50);
                    } catch (InterruptedException e) {
                        Thread.currentThread().interrupt();
                    }
                }
            }
            task.setOnlyIf(t -> config.getEnabled().get());
            task.getToken().set(accessTokenProvider);
            task.getPort().set(explicitPort.orElse(project.getProviders().fileContents(portFile).getAsText().map(Integer::parseInt)));
            task.getOutputDirectory().set(project.getLayout().getBuildDirectory().dir("generated-resources/test-resources-server"));
        });
    }

    private void warnAboutPotentialSecurityIssue(Project project) {
        if (warned.compareAndSet(false, true)) {
            project.getLogger().warn(
                    "********************************************\n" +
                            "* WARNING: an explicit port was configured *\n" +
                            "* for the test resources server: it will   *\n" +
                            "* accept any incoming connection from the  *\n" +
                            "* loopback network interface.              *\n" +
                            "********************************************\n"
            );
        }
    }

    private TestResourcesConfiguration createTestResourcesConfiguration(Project project, Provider<Integer> explicitPort) {
        MicronautExtension micronautExtension = project.getExtensions().getByType(MicronautExtension.class);
        TestResourcesConfiguration testResources = micronautExtension.getExtensions().create("testResources", TestResourcesConfiguration.class);
        testResources.getEnabled().convention(
                micronautExtension.getVersion()
                        .orElse(project.getProviders().gradleProperty("micronautVersion"))
                        .map(MicronautTestResourcesPlugin::isAtLeastMicronaut3dot5)
        );
        testResources.getVersion().convention(VersionInfo.getVersion());
        testResources.getExplicitPort().convention(explicitPort);
        testResources.getInferClasspath().convention(true);
        return testResources;
    }

    private static boolean isAtLeastMicronaut3dot5(String v) {
        String[] parts = v.split("\\.");
        if (parts.length >= 2) {
            int major = Integer.parseInt(parts[0]);
            int minor = Integer.parseInt(parts[1]);
            if (major > 3 || (major == 3 && minor >= 5)) {
                return true;
            }
            return false;
        }
        return false;
    }

    private Provider<List<Dependency>> buildTestResourcesDependencyList(Project project, DependencyHandler dependencies, TestResourcesConfiguration config) {
        return config.getEnabled().zip(config.getInferClasspath(), (enabled, infer) -> {
            if (Boolean.FALSE.equals(enabled)) {
                return Collections.<Dependency>emptyList();
            }
            List<MavenDependency> mavenDependencies = Collections.emptyList();
            if (Boolean.TRUE.equals(infer)) {
                mavenDependencies = project.getConfigurations().getByName("runtimeClasspath")
                        .getAllDependencies()
                        .stream()
                        .filter(ModuleDependency.class::isInstance)
                        .map(ModuleDependency.class::cast)
                        .map(d -> new MavenDependency(d.getGroup(), d.getName(), d.getVersion()))
                        .collect(Collectors.toList());
            }
            String testResourcesVersion = config.getVersion().get();
            return Stream.concat(
                            TestResourcesClasspath.inferTestResourcesClasspath(mavenDependencies, testResourcesVersion)
                                    .stream()
                                    .map(Object::toString),
                            config.getAdditionalModules().getOrElse(Collections.emptyList())
                                    .stream()
                                    .map(m -> "io.micronaut.testresources:micronaut-test-resources-" + m + ":" + testResourcesVersion))
                    .map(dependencies::create)
                    .collect(Collectors.toList());
        }).orElse(Collections.emptyList());
    }

    private void configureServiceReset(ProjectInternal project) {
        ServiceRegistry services = project.getServices();
        ListenerManager listenerManager = services.get(ListenerManager.class);
        Field parentField;
        try {
            parentField = listenerManager.getClass().getDeclaredField("parent");

            parentField.setAccessible(true);
            listenerManager = (ListenerManager) parentField.get(parentField.get(listenerManager));
            listenerManager.addListener(new BuildSessionLifecycleListener() {
                @Override
                public void beforeComplete() {
                    TestResourcesService.reset();
                }
            });
        } catch (NoSuchFieldException | IllegalAccessException e) {
            throw new GradleException(e.getMessage(), e);
        }
    }

    private static Configuration createTestResourcesServerConfiguration(Project project) {
        return project.getConfigurations().create("testresources", conf -> {
            conf.setDescription("Dependencies for the Micronaut test resources service");
            conf.setCanBeConsumed(false);
            conf.setCanBeResolved(true);
        });
    }

}
